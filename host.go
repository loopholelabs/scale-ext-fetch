// Code generated by scale-signature-go v0.1.0, DO NOT EDIT.
// schema: HttpFetch:alpha
// output: extfetch

package extfetch

import (
	"context"
	"errors"
	"sync"
	"sync/atomic"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"

	"github.com/loopholelabs/polyglot"
)

const identifier = "HttpFetch:alpha"

// Interface to the extension impl. This is what the implementor should create

type HttpFetchIfc interface {
	New(params *HttpConfig) (HttpConnector, error)
}

// TODO: Atm the interfaces are defined in guest. They should be pulled out somewhere prolly.

// Write an error to the scale function guest buffer.
func hostError(ctx context.Context, mod api.Module, err error) {
	b := polyglot.NewBuffer()
	polyglot.Encoder(b).Error(err)

	writeBuffer, err := mod.ExportedFunction("ext_HttpFetch_Resize").Call(ctx, uint64(b.Len()))

	if err != nil {
		panic(err)
	}

	if !mod.Memory().Write(uint32(writeBuffer[0]), b.Bytes()) {
		panic(err)
	}
}

func InstallExtension(module wazero.HostModuleBuilder, impl HttpFetchIfc) {

	hostWrapper := &HttpFetchHost{impl: impl}

	// Add global functions to the runtime

	fn := hostWrapper.host_ext_HttpFetch_New

	module.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(fn), []api.ValueType{api.ValueTypeI32, api.ValueTypeI32}, []api.ValueType{api.ValueTypeI64}).
		WithParameterNames("instance", "pointer", "length").Export("ext_HttpFetch_New")

	hostWrapper.instances_HttpConnector = make(map[uint64]HttpConnector)

	fn = hostWrapper.host_ext_HttpFetch_HttpConnector_Fetch

	module.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(fn), []api.ValueType{api.ValueTypeI64, api.ValueTypeI32, api.ValueTypeI32}, []api.ValueType{api.ValueTypeI64}).
		WithParameterNames("instance", "pointer", "length").Export("ext_HttpFetch_HttpConnector_Fetch")

}

type HttpFetchHost struct {
	impl HttpFetchIfc

	gid_HttpConnector           uint64
	instancesLock_HttpConnector sync.Mutex
	instances_HttpConnector     map[uint64]HttpConnector
}

// Global functions

func (h *HttpFetchHost) host_ext_HttpFetch_New(ctx context.Context, mod api.Module, params []uint64) {
	ptr := uint32(params[0])
	length := uint32(params[1])
	mem := mod.Memory()
	data, _ := mem.Read(ptr, length)

	cd := &HttpConfig{}
	cd, err := DecodeHttpConfig(cd, data)
	if err != nil {
		hostError(ctx, mod, err)
	}

	// Call the implementation
	r, err := h.impl.New(cd)
	if err != nil {
		hostError(ctx, mod, err)
	}

	id := atomic.AddUint64(&h.gid_HttpConnector, 1)
	h.instancesLock_HttpConnector.Lock()
	h.instances_HttpConnector[id] = r
	h.instancesLock_HttpConnector.Unlock()

	// Return the ID
	params[0] = id

}

func (h *HttpFetchHost) host_ext_HttpFetch_HttpConnector_Fetch(ctx context.Context, mod api.Module, params []uint64) {
	h.instancesLock_HttpConnector.Lock()
	r, ok := h.instances_HttpConnector[params[0]]
	h.instancesLock_HttpConnector.Unlock()
	if !ok {
		hostError(ctx, mod, errors.New("Instance ID not found!"))
	}

	ptr := uint32(params[1])
	length := uint32(params[2])
	mem := mod.Memory()
	data, _ := mem.Read(ptr, length)

	cd := &ConnectionDetails{}
	cd, err := DecodeConnectionDetails(cd, data)
	if err != nil {
		hostError(ctx, mod, err)
	}

	resp, err := r.Fetch(cd)
	if err != nil {
		hostError(ctx, mod, err)
	}

	b := polyglot.NewBuffer()
	resp.Encode(b)

	writeBuffer, err := mod.ExportedFunction("ext_HttpFetch_Resize").Call(ctx, uint64(b.Len()))

	if err != nil {
		hostError(ctx, mod, err)
	}

	if !mod.Memory().Write(uint32(writeBuffer[0]), b.Bytes()) {
		hostError(ctx, mod, err)
	}

}
