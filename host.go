// Code generated by scale-signature-go v0.1.0, DO NOT EDIT.
// schema: HttpFetch:alpha
// output: extfetch

package extfetch

import (
	"context"
	"errors"
	"sync/atomic"
	"sync"

	"github.com/loopholelabs/polyglot"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
)

var gid uint64 = 0
var instancesLock sync.Mutex
var instances map[uint64]*HostHttpConnector

func NewHost(module wazero.HostModuleBuilder) {
	module.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(host_ext_HttpFetch_HttpConnector_Fetch), []api.ValueType{api.ValueTypeI64, api.ValueTypeI32, api.ValueTypeI32}, []api.ValueType{api.ValueTypeI64}).
		WithParameterNames("instance", "pointer", "length").Export("ext_HttpFetch_HttpConnector_Fetch")

	module.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(host_ext_HttpFetch_New), []api.ValueType{api.ValueTypeI32, api.ValueTypeI32}, []api.ValueType{api.ValueTypeI64}).
		WithParameterNames("instance", "pointer", "length").Export("ext_HttpFetch_New")

	instances = make(map[uint64]*HostHttpConnector)
}

func host_ext_HttpFetch_New(ctx context.Context, mod api.Module, params []uint64) {
	ptr := uint32(params[0])
	length := uint32(params[1])
	mem := mod.Memory()
	data, _ := mem.Read(ptr, length)

	cd := &HttpConfig{}
	cd, err := DecodeHttpConfig(cd, data)
	if err != nil {
		hostError(ctx, mod, err)
	}

	r, err := HostNew(cd)
	if err!=nil {
		hostError(ctx, mod, err)
	}

	id := atomic.AddUint64(&gid, 1)
	instancesLock.Lock()
	instances[id] = r
	instancesLock.Unlock()

	// Return the ID
	params[0] = id
}

func host_ext_HttpFetch_HttpConnector_Fetch(ctx context.Context, mod api.Module, params []uint64) {
	r, ok := instances[params[0]]
	if !ok {
		hostError(ctx, mod, errors.New("Instance ID not found!"))
	}

	ptr := uint32(params[1])
	length := uint32(params[2])
	mem := mod.Memory()
	data, _ := mem.Read(ptr, length)

	cd := &ConnectionDetails{}
	cd, err := DecodeConnectionDetails(cd, data)
	if err != nil {
		hostError(ctx, mod, err)
	}

	resp, err := r.Fetch(cd)
	if err != nil {
		hostError(ctx, mod, err)
	}

	// Write it, and return the packed

	b := polyglot.NewBuffer()
	resp.Encode(b)

	writeBuffer, err := mod.ExportedFunction("ext_HttpFetch_Resize").Call(ctx, uint64(b.Len()))

	if err != nil {
		hostError(ctx, mod, err)
	}

	if !mod.Memory().Write(uint32(writeBuffer[0]), b.Bytes()) {
		hostError(ctx, mod, err)
	}
}

// Write an error to the scale function guest buffer.
func hostError(ctx context.Context, mod api.Module, err error) {
	b := polyglot.NewBuffer()
	polyglot.Encoder(b).Error(err)

	writeBuffer, err := mod.ExportedFunction("ext_HttpFetch_Resize").Call(ctx, uint64(b.Len()))

	if err != nil {
		panic(err)
	}

	if !mod.Memory().Write(uint32(writeBuffer[0]), b.Bytes()) {
		panic(err)
	}
}
